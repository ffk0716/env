#!/usr/bin/env python3

import argparse
import datetime as dt
import exiftool
import os
import re

dropbox_format = '%Y-%m-%d %H.%M.%S'
dropbox_re = re.compile(r'(\d{4}-\d{2}-\d{2} \d{2}\.\d{2}\.\d{2})')


# handle Chinese character correctly
def get_len(s):
    l = len(s)
    utf8_l = len(s.encode('utf-8'))
    return int((utf8_l - l) / 2 + l)


def fix_width(s, w):
    l = len(s)
    rl = get_len(s)
    w = w - (rl - l)
    return f'{s:{w}}'


def delta_to_str(d):
    if d < dt.timedelta():
        d = -d
        return f'-{d}'
    return f'+{d}'


def str_to_datetime(s):
    if not dropbox_re.match(s):
        return None
    s = dropbox_re.search(s).group(1)
    return dt.datetime.strptime(s, dropbox_format)


def roots_to_delta(a, b):
    a = str_to_datetime(a)
    b = str_to_datetime(b)
    if a and b:
        return b - a
    return None


def split_path(path):
    head, tail = os.path.split(path)
    root, ext = os.path.splitext(tail)
    return head, root, ext.lower().lstrip('.')


class tag_agent():

    et = exiftool.ExifToolHelper()

    def __init__(self, fname):
        pass

    def get_tag(self, fname, tag_name):
        if type(tag_name) == list:
            for t in tag_name:
                v = self.get_tag(fname, t)
                if v != None:
                    return v
            else:
                return None

        tags = self.et.get_tags(fname, tag_name)[0]
        if tag_name in tags:
            return tags[tag_name]
        if len(tags) > 1:
            print(tags)
        return None


class file_agent():

    def __init__(self, fname, default_time_zone):
        self.fname = fname
        self.c_time = None
        self.timezone = None
        self.warning_msg = []
        self.no_time_reason = 'no tag'
        self.no_size = False
        self.author = None
        self.dev = None
        self.tail = None
        self.verbose_level = 2
        if os.path.getsize(fname) == 0:
            self.no_size = True
            self.no_time_reason = 'empty file'
            return
        te = tag_agent(fname)
        self.author = te.get_tag(self.fname, ["EXIF:Artist", "QuickTime:Artist"])
        _, _, ext = split_path(fname)
        self.dev = te.get_tag(fname, ["EXIF:Model", "QuickTime:Model", "XML:DeviceModelName", "QuickTime:Encoder"])
        # jpg files
        time_string = te.get_tag(fname, "EXIF:CreateDate")
        if time_string != None:
            assert ext in ["jpg", "heic"], f"unknown extension: {ext}"
            if time_string == "0000:00:00 00:00:00":
                self.no_time_reason = "0000"
            else:
                self.c_time = dt.datetime.strptime(time_string, '%Y:%m:%d %H:%M:%S')
            time_string = te.get_tag(fname, "EXIF:OffsetTime")
            if time_string != None:
                self.timezone = dt.datetime.strptime(time_string, '%z').utcoffset()
            return
        # mov files
        time_string = te.get_tag(fname, "QuickTime:CreationDate")
        if time_string != None:
            assert ext in ["mov"]
            self.c_time = dt.datetime.strptime(time_string, '%Y:%m:%d %H:%M:%S%z')
            self.timezone = self.c_time.utcoffset()
            return
        # mp4 files
        time_string = te.get_tag(fname, "QuickTime:CreateDate")
        if time_string != None:
            assert ext in ["mp4", "mov"]
            if time_string == "0000:00:00 00:00:00":
                self.no_time_reason = "0000"
            else:
                self.c_time = dt.datetime.strptime(time_string, '%Y:%m:%d %H:%M:%S')
            self.timezone = te.get_tag(fname, "QuickTime:TimeZone")
            is_local = False
            if self.dev in ['DJIAction2', 'DJI OsmoAction4']:
                assert self.timezone == None
            elif self.dev in ['FDR-AX43A']:
                assert self.timezone != None
                self.timezone = dt.timedelta(minutes=int(self.timezone))
            else:
                assert self.timezone == None
                if self.dev:
                    self.verbose_level = min(self.verbose_level, 0)
                    self.warning_msg.append(f'unsupported device {self.dev}')
            if self.c_time:
                if not is_local:
                    if self.timezone:
                        self.c_time += self.timezone
                    else:
                        self.c_time += dt.timedelta(hours=default_time_zone)

    def info(self):
        s = ''
        if self.c_time:
            s += self.c_time.strftime(dropbox_format)
        else:
            s += f'{self.no_time_reason:19}'
        s += ' '
        if self.timezone:
            s += delta_to_str(self.timezone)
        else:
            s += ' ' * 8
        if not self.author:
            self.author = ''
        s += f" {self.author:10}"

        if self.dev:
            s += f" {self.dev:15}"
        else:
            s += f" {'':15}"
        return s

    def set_vb(self, n, tail):
        if self.tail == None or n <= self.verbose_level:
            self.tail = tail
        if n <= self.verbose_level:
            self.verbose_level = n

    def print(self):
        print(f"{fix_width(self.fname, max_n)}: {self.info()}: {self.tail}")
        for m in self.warning_msg:
            print(f"    {m}")


if __name__ == '__main__':
    # Get input file name
    parser = argparse.ArgumentParser("my exif")
    parser.add_argument('-i', '--input', nargs='+', help='input files')
    parser.add_argument('-n', '--dry', action="store_true", help='dry run')
    parser.add_argument('-f', '--fast', action="store_true", help='ignore file with dropbox foramt')
    parser.add_argument('-a', '--append', action="store_true", help='append old name')
    parser.add_argument('-v', '--verbose', action='count', default=0, help='verbose')
    parser.add_argument('-o', '--offset', type=int, help='offset')
    parser.add_argument('-z', '--timezone', type=int, default=8, help='default timezone if not exist')
    parser.add_argument('-e',
                        '--ext',
                        nargs='+',
                        type=str,
                        default=['jpg', 'mov', 'mp4', 'heic', 'png', 'jpeg'],
                        help='handle file only with specified extensions')
    args = parser.parse_args()

    file_total = 0
    file_no_timing = 0
    file_no_exif = 0
    file_no_change = 0
    file_update = 0

    def get_new_root(old_path, offset, default_time_zone):
        global file_no_exif
        a = file_agent(old_path, default_time_zone)
        c_time, timezone = a.c_time, a.timezone
        if c_time == None:
            a.set_vb(0, "skip, no timing tag")
            file_no_exif += 1
            _, old_root, _ = split_path(old_path)
            c_time = str_to_datetime(old_root)
        if c_time:
            if offset:
                c_time += dt.timedelta(hours=offset)
            c_time = c_time.strftime(dropbox_format)
        return c_time, a

    def handle(max_n, old_path):
        global file_total
        global file_no_change
        global file_update
        global file_no_timing
        head, old_root, ext = split_path(f)
        file_total += 1
        # get new root
        new_root, a = get_new_root(old_path, args.offset, args.timezone)
        if new_root == None:
            a.set_vb(1, "skip, no timing info")
            file_no_timing += 1
            return a

        # keep old name
        if dropbox_re.match(old_root):
            new_root = dropbox_re.sub(new_root, old_root)

        if args.append:
            new_root = f'{new_root} {old_root}'

        # skip if name does not change
        if old_root == new_root:
            a.set_vb(2, "skip, no change")
            file_no_change += 1
            return a

        # get delta string
        d = roots_to_delta(old_root, new_root)
        if d:
            d_str = f' ({delta_to_str(d)})'
        else:
            d_str = ' ' * 9

        # fix name conflict
        new_path_try = os.path.join(head, f'{new_root}.{ext}')
        file_count = 1
        while os.path.isfile(new_path_try):
            new_path_try = os.path.join(head, f'{new_root}-{file_count}.{ext}')
            file_count += 1

        # rentime_offset ame
        a.set_vb(0, f'-> {d_str} {new_path_try}')
        file_update += 1
        if not args.dry:
            os.rename(old_path, new_path_try)
        return a

    file_list = []
    for f in args.input:
        if os.path.isdir(f):
            for dirpath, dirnames, filenames in os.walk(f):
                for filename in filenames:
                    if filename in ['.DS_Store']:
                        continue
                    file_list.append(os.path.join(dirpath, filename))
        else:
            file_list.append(f)

    if args.fast:
        file_list3 = []
        for f in file_list:
            head, old_root, ext = split_path(f)
            if not dropbox_re.match(old_root):
                file_list3.append(f)
        file_list = file_list3

    file_list2 = []
    ext_list = set()
    for f in file_list:
        head, old_root, ext = split_path(f)
        if not args.ext or ext in args.ext:
            file_list2.append(f)
        else:
            ext_list.add(ext)
    if '' in ext_list:
        ext_list.remove('')
        ext_list.add('<no_ext>')
    total_n = len(file_list2)
    if args.verbose >= 1:
        print(f'Total files: {len(file_list)}')
        print(f'Total files to scan: {len(file_list2)}')
        print(f'Skip files: {", ".join(ext_list)}')
    max_n = 0
    if file_list2:
        max_n = max(get_len(s) for s in file_list2)
    i = 0
    for f in sorted(file_list2):
        try:
            a = handle(max_n, f)
        except Exception as e:
            print(f'debug: {f}')
            print(e)
            exit(1)
        if a.verbose_level <= args.verbose:
            prefix_n = len(str(total_n))
            prefix = f"({i:>{prefix_n}}/{total_n})"
            print(prefix, end='')
            a.print()
        i += 1
    assert file_total == (file_no_timing + file_no_change + file_update)
    print(f'Total files scaned:  {file_total}')
    print(f'  No exif:           {file_no_exif}')
    print(f'  Skip files:        {file_total - file_update}')
    print(f'    Same name:       {file_no_change}')
    print(f'    No timing:       {file_no_timing}')
    if args.dry:
        print(f'  Update files(dry): {file_update}')
    else:
        print(f'  Update files:      {file_update}')
