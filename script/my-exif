#!/usr/bin/env python3

import exiftool
import os
import argparse
import re
import datetime as dt

dropbox_format = '%Y-%m-%d %H.%M.%S'
dropbox_re = re.compile(r'^(\d{4}-\d{2}-\d* \d*.\d*.\d*)')


# handle Chinese character correctly
def get_len(s):
    l = len(s)
    utf8_l = len(s.encode('utf-8'))
    return int((utf8_l - l) / 2 + l)


def pw(s, w):
    l = len(s)
    rl = get_len(s)
    w = w - (rl - l)
    return f'{s:{w}}'


def delta_to_str(d):
    if d < dt.timedelta():
        d = -d
        return f'-{d}'
    return f'+{d}'


def str_to_datetime(s):
    if not dropbox_re.match(s):
        return None
    s = dropbox_re.search(s).group(1)
    return dt.datetime.strptime(s, dropbox_format)


def roots_to_delta(a, b):
    a = str_to_datetime(a)
    b = str_to_datetime(b)
    if a and b:
        return b - a
    return None


def split_path(path):
    head, tail = os.path.split(path)
    root, ext = os.path.splitext(tail)
    return head, root, ext.lower().lstrip('.')


def get_tag(fname, tag_name):
    if type(tag_name) == list:
        for t in tag_name:
            v = get_tag(fname, t)
            if v != None:
                return v
        else:
            return None

    with exiftool.ExifToolHelper() as et:
        tags = et.get_tags(fname, tag_name)[0]
        if tag_name in tags:
            return tags[tag_name]
        if len(tags) > 1:
            print(tags)
        return None


def get_utc(fname, default_time_zone):
    info = []
    _, _, ext = split_path(fname)
    dev = get_tag(fname,
                  ["EXIF:Model", "XML:DeviceModelName", "QuickTime:Encoder"])
    if not dev:
        info.append('unknow device')
    # jpg files
    time_string = get_tag(fname, "EXIF:CreateDate")
    if time_string != None:
        assert ext in ["jpg", "heic"]
        c_time = dt.datetime.strptime(time_string, '%Y:%m:%d %H:%M:%S')
        time_string = get_tag(fname, "EXIF:OffsetTime")
        if time_string != None:
            timezone = dt.datetime.strptime(time_string, '%z').utcoffset()
        else:
            timezone = None
        return info, c_time, timezone
    # mov files
    time_string = get_tag(fname, "QuickTime:CreationDate")
    if time_string != None:
        assert ext in ["mov"]
        c_time = dt.datetime.strptime(time_string, '%Y:%m:%d %H:%M:%S%z')
        return info, c_time, c_time.utcoffset()
    # mp4 files
    time_string = get_tag(fname, "QuickTime:CreateDate")
    if time_string != None:
        assert ext in ["mp4"]
        if time_string == "0000:00:00 00:00:00":
            info.append("no timing")
            c_time = None
        else:
            c_time = dt.datetime.strptime(time_string, '%Y:%m:%d %H:%M:%S')
        timezone = None
        is_local = False
        if dev in ['DJIAction2', 'DJI OsmoAction4']:
            pass
        elif dev in ['FDR-AX43A']:
            is_local = False
            t = get_tag(fname, "QuickTime:TimeZone")
            timezone = dt.timedelta(minutes=int(t))
        else:
            is_local = False
            if dev:
                info.append(f'unsupported device {dev}')
        if c_time:
            if not is_local:
                if timezone:
                    c_time += timezone
                else:
                    c_time += dt.timedelta(hours=default_time_zone)
        return info, c_time, timezone
    return info, None, None


if __name__ == '__main__':
    # Get input file name
    parser = argparse.ArgumentParser("my exif")
    parser.add_argument('-i', '--input', nargs='+', help='input files')
    parser.add_argument('-n', '--dry', action="store_true", help='dry run')
    parser.add_argument('-v', '--verbose', action='count', help='verbose')
    parser.add_argument('-o', '--offset', type=int, help='offset')
    parser.add_argument('-z',
                        '--timezone',
                        type=int,
                        default=8,
                        help='default timezone if not exist')
    parser.add_argument('-e',
                        '--ext',
                        nargs='+',
                        type=str,
                        default=['jpg', 'mov', 'mp4', 'heic'],
                        help='handle file only with specified extensions')
    args = parser.parse_args()

    file_total = 0
    file_no_timing = 0
    file_no_exif = 0
    file_no_change = 0
    file_update = 0

    def get_new_root(old_path, offset, default_time_zone):
        global file_no_exif
        info, c_time, timezone = get_utc(old_path, default_time_zone)
        if c_time == None:
            file_no_exif += 1
            _, old_root, _ = split_path(old_path)
            c_time = str_to_datetime(old_root)
            info.append("no exif")
        if c_time:
            if offset:
                c_time += dt.timedelta(hours=offset)
            c_time = c_time.strftime(dropbox_format)
        if timezone != None:
            info.append(delta_to_str(timezone))
        author = get_tag(old_path, ["EXIF:Artist", "QuickTime:Artist"])
        if author:
            info.append(author)
        info = ', '.join(info)
        if info:
            info = f' ({info})'
        return c_time, info

    def handle(max_n, old_path):
        global file_total
        global file_no_change
        global file_update
        global file_no_timing
        head, old_root, ext = split_path(f)
        file_total += 1
        # get new root
        new_root, info = get_new_root(old_path, args.offset, args.timezone)
        if new_root == None:
            if args.verbose >= 1:
                print(f"{pw(old_path, max_n)}:{info} skip, no timing info")
            file_no_timing += 1
            return

        # keep old name
        if dropbox_re.match(old_root):
            new_root = dropbox_re.sub(new_root, old_root)

        # skip if name does not change
        if old_root == new_root:
            if args.verbose >= 2:
                print(f'{pw(old_path, max_n)}:{info} skip, no change')
            file_no_change += 1
            return

        # get delta string
        d = roots_to_delta(old_root, new_root)
        if d:
            d_str = f' ({delta_to_str(d)})'
        else:
            d_str = ''

        # fix name conflict
        new_path_try = os.path.join(head, f'{new_root}.{ext}')
        file_count = 1
        while os.path.isfile(new_path_try):
            new_path_try = os.path.join(head, f'{new_root}-{file_count}.{ext}')
            file_count += 1

        # rentime_offset ame
        print(f'{old_path} -> {info} j {new_path_try}{d_str}')
        file_update += 1
        if not args.dry:
            os.rename(old_path, new_path_try)

    file_list = []
    for f in args.input:
        if os.path.isdir(f):
            for dirpath, dirnames, filenames in os.walk(f):
                for filename in filenames:
                    if filename in ['.DS_Store']:
                        continue
                    file_list.append(os.path.join(dirpath, filename))
        else:
            file_list.append(f)

    file_list2 = []
    for f in file_list:
        head, old_root, ext = split_path(f)
        if not args.ext or ext in args.ext:
            file_list2.append(f)
    if args.verbose >= 1:
        print(f'Total files to scan: {len(file_list2)}')
    max_n = max(get_len(s) for s in file_list2)
    for f in sorted(file_list2):
        handle(max_n, f)
    assert file_total == (file_no_timing + file_no_change + file_update)
    print(f'Total files scaned:  {file_total}')
    print(f'  No change files:   {file_total - file_update}')
    print(f'    Same name:       {file_no_change}')
    print(f'    No timing:       {file_no_timing}')
    print(f'      No exif:       {file_no_exif}')
    if args.dry:
        print(f'  Update files(dry): {file_update}')
    else:
        print(f'  Update files:      {file_update}')
